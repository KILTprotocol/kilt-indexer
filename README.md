# SubQuery - Example Project for Kilt Spiritnet

[SubQuery](https://subquery.network) is a fast, flexible, and reliable open-source data indexer that provides you with custom APIs for your web3 project across all of our supported networks. To learn about how to get started with SubQuery, [visit our docs](https://academy.subquery.network).

**This SubQuery project indexes all attestations and daily aggregations on the Kilt Spiritnet Network**

## Start

First, install SubQuery CLI globally on your terminal by using NPM `npm install -g @subql/cli`

You can either clone this GitHub repo, or use the `subql` CLI to bootstrap a clean project in the network of your choosing by running `subql init` and following the prompts.

Don't forget to install dependencies with `npm install` or `yarn install`!

## Editing your SubQuery project

Although this is a working example SubQuery project, you can edit the SubQuery project by changing the following files:

- The project manifest in `project.yaml` defines the key project configuration and mapping handler filters.
  `project.yaml` is autogenerated from `project.ts.`
- The GraphQL Schema (`schema.graphql`) defines the shape of the resulting data that you are using SubQuery to index
- The Mapping functions in `src/mappings/` directory are typescript functions that handle transformation logic

SubQuery supports various layer-1 blockchain networks and provides [dedicated quick start guides](https://academy.subquery.network/quickstart/quickstart.html) as well as [detailed technical documentation](https://academy.subquery.network/build/introduction.html) for each of them.

## Run your project

_If you get stuck, find out how to get help below._

The simplest way to run your project is by running `yarn dev` or `npm run-script dev`. This does all of the following:

1.  `yarn codegen` - Generates types from the GraphQL schema definition and contract ABIs and saves them in the `/src/types` directory. This must be done after each change to the `schema.graphql` file or the contract ABIs
2.  `yarn build` - Builds and packages the SubQuery project into the `/dist` directory
3.  `yarn start:docker` alias to `docker-compose pull && docker-compose up` - Runs a Docker container with an indexer, PostgeSQL DB, and a query service. This requires [Docker to be installed](https://docs.docker.com/engine/install) and running locally. The configuration for this container is set from your `docker-compose.yml`

You can observe the three services start, and once all are running (it may take a few minutes on your first start), please open your browser and head to [http://localhost:3000](http://localhost:3000) - you should see a GraphQL playground showing with the schemas ready to query. [Read the docs for more information](https://academy.subquery.network/run_publish/run.html) or [explore the possible service configuration for running SubQuery](https://academy.subquery.network/run_publish/references.html).

If you change `schema.graphql`, `project.ts` or `mappingHandlers.ts` all autogenerated files during `yarn dev` will be overwritten, with the big exception of the database inside `.data/`.
If you make incompatible changes to any of those files, make sure you delete `.data/` before running `yarn dev`.

Additionally, you can run `yarn slash` to delete all autogenerated files at once, including the database.

## Publish your project

SubQuery is open-source, meaning you have the freedom to run it in the following three ways:

- Locally on your own computer (or a cloud provider of your choosing), [view the instructions on how to run SubQuery Locally](https://academy.subquery.network/run_publish/run.html)
- By publishing it to our enterprise-level [Managed Service](https://managedservice.subquery.network), where we'll host your SubQuery project in production ready services for mission critical data with zero-downtime blue/green deployments. We even have a generous free tier. [Find out how](https://academy.subquery.network/run_publish/publish.html)
- [Coming Soon] By publishing it to the decentralized [SubQuery Network](https://subquery.network/network), the most open, performant, reliable, and scalable data service for dApp developers. The SubQuery Network indexes and services data to the global community in an incentivised and verifiable way

## What Next?

Take a look at some of our advanced features to take your project to the next level!

- [**Multi-chain indexing support**](https://academy.subquery.network/build/multi-chain.html) - SubQuery allows you to index data from across different layer-1 networks into the same database, this allows you to query a single endpoint to get data for all supported networks.
- [**Dynamic Data Sources**](https://academy.subquery.network/build/dynamicdatasources.html) - When you want to index factory contracts, for example on a DEX or generative NFT project.
- [**Project Optimisation Advice**](https://academy.subquery.network/build/optimisation.html) - Some common tips on how to tweak your project to maximize performance.
- [**GraphQL Subscriptions**](https://academy.subquery.network/run_publish/subscription.html) - Build more reactive front end applications that subscribe to changes in your SubQuery project.

## Need Help?

The fastest way to get support is by [searching our documentation](https://academy.subquery.network), or by [joining our discord](https://discord.com/invite/subquery) and messaging us in the `#technical-support` channel.

To get more logs while debugging go to `docker-compose.yml` and uncomment `- --log-level=trace`.

## For Queries:

For this project, you can visit the playground under http://localhost:3000/ and try to query on of the following GraphQL code to get a taste of how it works.

You can explore the different possible queries and entities to help you with GraphQL using the documentation draw on the right.

Most of the example queries below take advantage of the example fragments.
You need to add the fragments to the playground as well, if you want to run queries using those fragments.

Tip: Commas are irrelevant.

### Useful Fragments:

GraphQL provides reusable units called _fragments_.
Fragments let you construct sets of fields, and then include them in queries where you need to.

```
fragment wholeBlock on Block{
  id,
  hash,
  timeStamp,
}
```

```
fragment wholeAttestation on Attestation {
  id,
  claimHash,
  cTypeId,
  attester,
  payer,
  delegationID,
  valid,
  creationBlock {
    ...wholeBlock,
  },
  revocationBlock  {
    ...wholeBlock,
  },
  removalBlock {
    ...wholeBlock,
  },
}
```

### Query Examples:

1. ** Find Attestation by ID:**

- without a fragment:

```
query {
  attestations (filter: { id: {equalTo: "0x7554dc0b69be9bd6a266c865a951cae6a168c98b8047120dd8904ad54df5bb08"}} ){
    nodes{
        id,
      hash,
      timeStamp,
    }
  }
}

```

- with a fragment:

```
query {
  attestations (filter: { id: {equalTo: "0x7554dc0b69be9bd6a266c865a951cae6a168c98b8047120dd8904ad54df5bb08"}} ){
    nodes{
      ...wholeBlock,
    }
  }
}

```

2. ** Find all revoked attestations**

```
query {
  attestations(filter: {revocationBlockId: {isNull: false}} ) {
    totalCount,
    nodes{
      ...wholeAttestation,
    }
	}
}
```

3. ** Find how many attestations were made on a block: **

```
query {
  blocks(filter: {number: {equalTo: "3396407"}}){
    nodes {
    id,
    timeStamp,
    number,
      attestationsByCreationBlockId {
        totalCount,
        nodes{
          id,
          cType,
          claimHash,
          attester,
        }
      }
    }}
}
```

4. ** Find all cTypes that have been used at least once: **

```
query {
  cTypes(filter: {attestations: {some: {id: {isNull: false}}}}){
    totalCount
    nodes {
      id,
      author
      registrationBlock {  ...wholeBlock }
      attestationsCreated,
      attestationsRevoked,
      attestationsRemoved,
      attestations(orderBy: ID_ASC) {
        totalCount
        nodes{
          ...wholeAttestation
        }
      }
    }
  }
}
```
