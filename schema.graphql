# To improve query performance, we strongly suggest adding indexes to any field that you plan to filter or sort by
# Add the `@index` or `@index(unique: true)` annotation after any non-key field
# https://academy.subquery.network/build/graphql.html#indexing-by-non-primary-key-field

type Block @entity {
  id: ID! # <Block ordinal number from genesis block> fixed length of 9 digits, prefixed with insignificant zeros
  # The biggest possible block number on chain has 20 places (=u64).
  # To allow ordering by block number (=id), we need to prefix them with insignificant zeros, because IDs are always strings.
  # Currently (at ~7.5M blocks), only 7 significant places are being used. It would take more than 380 years to produce 1 billion blocks.
  # By normalizing block numbers to 9 digits, we are set up for the next 377 years.
  hash: String! @index(unique: true) # Block Hash as hex-string
  timeStamp: Date! # Date of creation of this block
}

## For Credentials:

type Attestation @entity {
  id: ID! # <Block number> + "-" + <ordinal number within block>
  claimHash: String! @index # hash of the credential claims. Can be duplicated
  cType: CType! @index # id of the CType used in this attestation. A.k.a.: "kilt:ctype:" + <CType hash>
  issuer: Did! @index # DID of credential issuer and on-chain attester
  payer: String! # account address
  delegationID: String
  valid: Boolean! @index
  creationBlock: Block!
  revocationBlock: Block
  removalBlock: Block
}

type CType @entity {
  # This is an Aggregation Entity allowing us to calculate all the attestations created, revoked and removed per CType
  id: ID! # "kilt:ctype:" + <CType hash>
  registrationBlock: Block!
  author: Did! @index # DID of the creator
  definition: String! # cType Schema
  attestationsCreated: Int!
  attestationsRevoked: Int!
  attestationsRemoved: Int! # either valid or revoked credentials can be removed.
  validAttestations: Int! # number of credentials neither revoked nor removed.
}

## For DIDs:

type Did @entity {
  id: ID! # "did:kilt:" + <identifier (encoded as KILT address)>
  payer: String! @index # owner account address
  creationBlock: Block!
  deletionBlock: Block
  web3name: Web3Name # w3n:user , only the current one
  active: Boolean! # whether it has been deactivated or not
}

type Web3Name @entity {
  id: ID! # "w3n:" + <user name>
  banned: Boolean!
  ownerships: [Ownership]! @derivedFrom(field: "name")
}

type Ownership @entity {
  id: ID! # "#" + <ordinal number> + "_" + "w3n:" + <user name>
  name: Web3Name! @index
  bearer: Did! @index
  payer: String! @index # owner account address
  claimBlock: Block!
  releaseBlock: Block
}

enum SanctionNature {
  permission
  prohibition
}

type Sanction @entity {
  id: ID! # "ยง" + <ordinal number> + "_" + "w3n:" + <user name>
  nature: SanctionNature!
  name: Web3Name! @index
  enforcementBlock: Block!
}

## For AssetDIDs:

type Chain @entity {
  id: ID! # <chain-namespace> + ":" + <chain-reference> = caip-2-chain-id
  namespace: String!
  reference: String!
}

type Asset @entity {
  id: ID! # <asset-namespace> + ":" + <asset-reference> + [":" + <asset-id>]
  namespace: String!
  reference: String!
  identifier: String
}

type AssetDID @entity {
  id: ID! # "did:asset:" + <chain-namespace> + ":" + <chain-reference> + <asset-namespace> + ":" + <asset-reference> + [":" + <asset-id>]
  chain: Chain!
  asset: Asset!
}

type PublicCredential @entity {
  id: ID! # <credential-hash>
  subject: AssetDID! @index
  cType: CType!
  issuer: Did! @index
  claims: String! # content of the credential
  delegationID: String
  valid: Boolean!
  updates: [Update]! @derivedFrom(field: "credential")
}

enum UpdateNature {
  creation
  revocation
  restoration # un-revocation
  removal
}

# TODO: change symbol of Updates differentiate from Sanctions. Maybe to "+" or "*".
type Update @entity {
  id: ID! # "ยง" + <ordinal number> + "_" + <credential-hash>
  credential: PublicCredential!
  nature: UpdateNature!
  updateBlock: Block!
}

## Idea:

# To make records of when a deposit was changed:
# - Make Enum listing all types of entities that can have their deposit owner changed
# - Make Entity (maybe call it "Reallocation") that adds a record of this change, compound of:
#      * ID of entity related
#      * for: DepositsReason
#      * Block
#      * old owner
#      * new owner
#

# enum DepositsReason {
#  DID
#  Attestation
#  PublicCredential
#  Web3name
# }

# type Reallocation @entity {
#  id: ID! #
#  for: DepositsReason
#  reallocationBlock: Block!
#  oldOwner: String! # account address
#  newOwner: String! # account address
# }
